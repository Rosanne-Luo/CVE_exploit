# CVE-2017-14491 漏洞分析
## 漏洞介绍
漏洞分类：堆溢出漏洞。
## 漏洞复现
### 实验环境
系统版本：虚拟机ubuntu 14.10

dnsmasq 版本：2.71
### 实验步骤
1、 打开一个终端，运行 CVE-2017-14491.py 
```
python CVE-2017-14491.py 127.0.0.2 53
```
这个脚本相当于一个DNS上游服务器。

2、 打开第二个终端，启动dnsmasq
```
dnsmasq -p 53535 --no-daemon --log-queries -S 127.0.0.2 --no-hosts --no-resolv
```
 -p : 指定监听端口
 
--no-daemon : debug 模式执行，不在后台运行

--log-queries:  记录DNS 查询

--no-hosts :  不加载/etc/hosts 文件

--no-resolv: 不poll /etc/resolv.conf 文件，只有当接收到 SIGHUP 信号时才重新加载该文件

-S : 指定上游server地址

3、 打开第三个终端，发送dns查询
```
dig @localhost -p 53535 -x 8.8.8.125 > /dev/null
dig @localhost -p 53535 -x 8.8.8.125 > /dev/null
```
-x : 逆向查询

-p：端口

 当第二次查询时，第二个窗口显示出现段错误
 
 [image1]
 
 ## 漏洞分析
 
 通过 wireshark 抓包分析，发现当dnsmasq 向上游服务器发送dns查询，上游服务器返回了82条记录
 对 dnsmasq 设置断点分析，发现导致段错误的语句是rfc1035.c 文件的answer_request 函数中
 ```
		  if (crecp)
		    {
		      do 
			{ 
			  /* don't answer wildcard queries with data not from /etc/hosts or dhcp leases */
			  if (qtype == T_ANY && !(crecp->flags & (F_HOSTS | F_DHCP)))
			    continue;
			  
			  if (!(crecp->flags & F_DNSSECOK))
			    sec_data = 0;
			  
			  if (crecp->flags & F_NEG)
			    {
			      ans = 1;
			      auth = 0;
			      if (crecp->flags & F_NXDOMAIN)
				nxdomain = 1;
			      if (!dryrun)
				log_query(crecp->flags & ~F_FORWARD, name, &addr, NULL);
			    }
			  else if ((crecp->flags & (F_HOSTS | F_DHCP)) || !sec_reqd || option_bool(OPT_DNSSEC_VALID))
			    {
			      ans = 1;
			      if (!(crecp->flags & (F_HOSTS | F_DHCP)))
				auth = 0;
			      if (!dryrun)
				{
				  log_query(crecp->flags & ~F_FORWARD, cache_get_name(crecp), &addr, 
					    record_source(crecp->uid));
				  if (add_resource_record(header, limit, &trunc, nameoffset, &ansp, 
							  crec_ttl(crecp, now), NULL,
							  T_PTR, C_IN, "d", cache_get_name(crecp)))
				    anscount++;
				}
			    }
			} while ((crecp = cache_find_by_addr(crecp, &addr, now, is_arpa)));
		    }
 ```
 当anscount为81时，进入最后一次while循环，再次调用cache_find_by_addr 函数出现段错误，具体代码为：
 ```
   if (ans && 
      (ans->flags & F_REVERSE) &&
 ```
 而ans此时的值为：
 imag3
 
 ans的值是由crecp得到的，而crecp指向的地址中的内容全部都是5a,说明在 add_resource_record 函数中出现溢出。
 进一步分析发现是do_rfc1035_name 函数在将域名复制到p指针指向的空间时出现了溢出
 ```
 unsigned char *do_rfc1035_name(unsigned char *p, char *sval)
{
  int j;
  
  while (sval && *sval)
    {
      unsigned char *cp = p++;
      for (j = 0; *sval && (*sval != '.'); sval++, j++)
	{
#ifdef HAVE_DNSSEC
	  if (option_bool(OPT_DNSSEC_VALID) && *sval == NAME_ESCAPE)
	    *p++ = (*(++sval))-1;
	  else
#endif		
	    *p++ = *sval;
	}
      *cp  = j;
      if (*sval)
	sval++;
    }
  return p;
}
 ```
第一次查询时，server返回了82条记录，这些记录的总长度为2221字节，其中第一条记录1024自己，第二条记录50字节，第3条记录与第2条记录的内容重复，只是用指针
指向第2条记录的name部分，因此只有14字节，后面遇到重复的内容都是这么处理。而第而次查询时从缓存中查找记录，将这些name值全部展开，因此会溢出。
